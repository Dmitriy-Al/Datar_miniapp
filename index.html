<!DOCTYPE html>
<html lang="ru">
  <head>
    <script src="https://telegram.org/js/telegram-web-app.js?59"></script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Система записи на прием</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: Arial, sans-serif;
        background-color: #f0f0f0;
        padding: 15px;
        min-height: 100vh;
        overflow-x: hidden;
      }

      /* Шапка с кнопками-клавишами */
      .header {
        height: 50px;
        background-color: #2c3e50;
        border-radius: 8px;
        margin-bottom: 15px;
        padding: 5px;
        overflow-x: auto;
        overflow-y: hidden;
        white-space: nowrap;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .keys-container {
        display: inline-flex;
        gap: 8px;
        height: 100%;
        align-items: center;
        padding: 0 10px;
      }

      .key-button {
        background: linear-gradient(135deg, #3498db, #2980b9);
        color: white;
        border: none;
        border-radius: 6px;
        padding: 8px 15px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        transition: all 0.3s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        min-width: 80px;
        text-align: center;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      /*margin-top: 40px;*/
      .key-button:hover {
        background: linear-gradient(135deg, #2980b9, #1f618d);
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }

      .key-button:active {
        transform: translateY(0);
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      }

      .container {
        display: grid;
        gap: 15px;
        width: 100%;
        max-width: 100%;
      }

      .column {
        background-color: #fcf8e1;
        border-radius: 5px;
        padding: 5px;
        min-height: 900px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        display: flex;
        flex-direction: column;
        position: relative;
      }

      /* Вертикальная шкала времени */
      .time-scale {
        position: absolute;
        left: 0;
        top: 60px; /* Начинаем от уровня заголовка столбца */
        bottom: 0px;
        width: 15px; /* 15px */
        background: linear-gradient(to bottom, #fff5e4, #fae4bd);
        border-right: 2px solid #3498db;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 10px 0;
        z-index: 1;
      }

      .time-marker {
        width: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        position: relative;
        flex: 1;
        min-height: 0;
      }

      .time-marker::after {
        content: "";
        position: absolute;
        right: -2px;
        width: 8px;
        height: 1px;
        background-color: #3498db;
        top: 50%;
        transform: translateY(-50%);
      }

      .time-marker.hour::after {
        width: 12px;
        height: 2px;
        background-color: #2980b9;
        top: 50%;
        transform: translateY(-50%);
      }
      .time-label {
        /*       margin-bottom: 5px;*/
        margin-top: 15px;
        margin-left: 16px;
        font-size: 10px;
        color: #2c3e50;
        font-weight: bold;
        right: -25px;
        background: white;
        padding: 1px 3px;
        border-radius: 2px;
        border: 1px solid #bdc3c7;
        /*     position: absolute; */
        top: 50%;
        transform: translateY(-50%);
        z-index: 2;
      }

      .column-content {
        margin-left: 15px;
        display: flex;
        flex-direction: column;
        flex-grow: 1;
      }

      .column:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      }

      .column h2 {
        text-align: center;
        margin-bottom: 15px;
        color: #333;
        border-bottom: 2px solid #3b648d;
        padding-bottom: 10px;
        font-size: 16px;
        height: 60px; /* Фиксируем высоту заголовка */
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .cards-container {
        display: flex;
        flex-direction: column;
        gap: 10px;
        flex-grow: 1;
        position: relative;
        height: 840px;
      }

      .card {
        background-color: #ffdc9c;
        border-radius: 5px;
        padding: 1px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        text-align: center;
        word-break: break-word;
        position: absolute;
        left: 0;
        right: 0;
        margin-top: -10px; /* -10px; Добавляем небольшое смещение для точного выравнивания */
        box-sizing: border-box;
      }

      .card:hover {
        transform: scale(1.05);
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }

      .card h3 {
        margin-bottom: 8px;
        color: black;
        font-size: 14px;
        font-weight: bold;
        /*   line-height: 1.2; */
      }

      .card p {
        color: black;
        font-size: 12px;
        font-weight: bold;
      }

      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 1000;
        backdrop-filter: blur(5px);
      }

      .modal-content {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 25px;
        border-radius: 15px;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        width: 90%;
        max-width: 400px;
        line-height: 2; /* разделение строк по высоте */
      }

      .modal h2 {
        margin-bottom: 15px;
        color: #333;
        text-align: center;
        font-size: 18px;
      }

      .modal input,
      .modal textarea,
      .modal select {
        width: 100%;
        padding: 12px;
        margin-bottom: 15px;
        border: 2px solid #ddd;
        border-radius: 8px;
        font-size: 16px;
        transition: border-color 0.3s;
      }

      .modal textarea {
        height: 80px;
        resize: vertical;
      }

      .modal input:focus,
      .modal textarea:focus,
      .modal select:focus {
        outline: none;
        border-color: #ffa500;
      }

      .readonly-field {
        background-color: #f5f5f5;
        color: #666;
        cursor: not-allowed;
      }

      .time-inputs-container {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
      }

      .time-input {
        flex: 1;
      }

      .modal-buttons {
        padding: 20px;
        display: flex;
        gap: 10px;
        justify-content: center;
      }

      .modal-button {
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        transition: all 0.3s;
        min-width: 80px;
      }
      /* #57ff5d  #e94e43 */
      .modal-button.ok {
        background-color: #6cc556;
        color: white;
      }

      .modal-button.cancel {
        background-color: #ffbe44;
        color: white;
      }

      .modal-button.cancelAppointment {
        background-color: #ff7b6a;
        color: white;
      }

      .modal-button:hover {
        opacity: 0.9;
        transform: translateY(-2px);
      }

      .empty-column {
        text-align: center;
        color: #666;
        font-style: italic;
        padding: 20px;
        font-size: 14px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-grow: 1;
        cursor: pointer;
      }

      .guest-message {
        text-align: center;
        color: #666;
        font-size: 24px;
        margin-top: 100px;
        font-weight: bold;
      }

      /* Стили для скроллбара в шапке */
      .header::-webkit-scrollbar {
        height: 6px;
      }

      .header::-webkit-scrollbar-track {
        background: #34495e;
        border-radius: 3px;
      }

      .header::-webkit-scrollbar-thumb {
        background: #3498db;
        border-radius: 3px;
      }

      .header::-webkit-scrollbar-thumb:hover {
        background: #2980b9;
      }

      /* Мобильные устройства - 3 столбца в ряд */
      @media (max-width: 767px) {
        .container {
          grid-template-columns: repeat(3, 1fr);
          gap: 10px;
        }

        .column {
          padding: 5px;
          min-height: 900px;
        }

        .time-scale {
          width: 15px;
          top: 40px; /* Меньший отступ для мобильных */
        }

        .time-label {
          font-size: 8px;
          right: -20px;
          margin-top: 10px; /*  Меньшее смещение для мобильных */
        }

        .column-content {
          margin-left: 10px;
        }

        .column h2 {
          height: 50px; /* Меньшая высота заголовка для мобильных */
          font-size: 14px;
          margin-bottom: 10px;
        }

        .cards-container {
          height: 900px; /* Половина высоты для мобильных */
        }

        .card {
          padding: 10px;
        }

        .card h3 {
          font-size: 8px; /* 12px */
        }

        .card p {
          font-size: 8px; /* 12px */
        }

        .key-button {
          padding: 6px 12px;
          font-size: 12px;
          min-width: 70px;
        }

        .time-inputs-container {
          flex-direction: column;
        }
      }

      /* Планшеты - 3 столбца в ряд */
      @media (min-width: 768px) and (max-width: 1023px) {
        .container {
          grid-template-columns: repeat(3, 1fr);
          gap: 20px;
          max-width: 1200px;
          margin: 0 auto;
        }

        .column {
          min-height: 900px;
        }
      }

      /* Десктоп - 5 столбцов в ряд */
      @media (min-width: 1024px) {
        .container {
          grid-template-columns: repeat(7, 1fr);
          max-width: 2000px;
          margin: 0 auto;
          gap: 20px;
        }

        .column {
          min-height: 900px;
        }
      }
    </style>
  </head>
  <body>
    <!-- Шапка с кнопками-клавишами (будет скрыта для специалистов) -->
    <div class="header" id="header" style="display: none">
      <div class="keys-container" id="keysContainer">
        <!-- Кнопки-клавиши будут созданы через JavaScript -->
      </div>
    </div>

    <div class="container" id="columnsContainer">
      <!-- Столбцы будут созданы через JavaScript -->
    </div>

    <!-- Модальное окно для добавления новой записи -->
    <div class="modal" id="addModal">
      <div class="modal-content">
        <h2>Записать</h2>
        <input
          type="text"
          id="searchClient"
          placeholder="Введите фамилию для поиска"
        />
        <div
          id="searchResults"
          style="max-height: 150px; overflow-y: auto; margin-bottom: 15px"
        ></div>
        <i>Дата и время начала</i>
        <input type="datetime-local" id="appointmentDateTime" />

        <div class="time-inputs-container">
          <ismall>Время окончания</small>
          <input type="time" id="appointmentEndTime" class="time-input" />
        </div>

        <textarea
          id="appointmentNote"
          placeholder="Добавить комментарий"
        ></textarea>
        <div class="modal-buttons">
          <button class="modal-button cancel" onclick="closeAddModal()">
            Отмена
          </button>
          <button class="modal-button ok" onclick="saveAppointment()">
            Записать
          </button>
        </div>
      </div>
    </div>

    <!-- Модальное окно для просмотра записи -->
    <div class="modal" id="viewModal">
      <div class="modal-content">
        <h2>Информация о записи</h2>
        <div id="clientInfo"></div>
        <div class="modal-buttons">
          <button
            class="modal-button cancelAppointment"
            onclick="cancelAppointment()"
          >
            Отменить запись
          </button>
          <button class="modal-button ok" onclick="closeViewModal()">
            Закрыть
          </button>
        </div>
      </div>
    </div>

    <script>
      let tg = window.Telegram.WebApp; // Аккаунта Telegram
      let tgUserId = tg.initDataUnsafe.user.id; // tg.initDataUnsafe.user.id; // Данные аккаунта пользователя Telegram

      const API_BASE = "https://alimovdev.ru/api"; //"http://localhost:8080/api";
      let currentSpecialist = null;
      let currentClients = [];
      let currentSelectedClient = null;
      let currentAppointmentIndex = null;

      // Функция для форматирования ФИО в формат "Фамилия И. О."
      function formatFullName(surname, name, patronymic) {
        const nameInitial = name ? `${name.charAt(0)}.` : "";
        const patronymicInitial = patronymic ? `${patronymic.charAt(0)}.` : "";
        return `${surname} ${nameInitial}${patronymicInitial}`;
      }

      // Функция для создания шкалы времени
      function createTimeScale(columnElement) {
        const timeScale = document.createElement("div");
        timeScale.className = "time-scale";

        // Время с 08:00 до 22:00 с шагом 10 минут
        const startHour = 8;
        const endHour = 22;

        for (let hour = startHour; hour <= endHour; hour++) {
          for (let minute = 0; minute < 60; minute += 10) {
            if (hour === endHour && minute > 0) break;

            const timeMarker = document.createElement("div");
            timeMarker.className = "time-marker";

            if (minute === 0) {
              timeMarker.classList.add("hour");

              const timeLabel = document.createElement("div");
              timeLabel.className = "time-label";
              timeLabel.textContent = `${hour.toString().padStart(2, "0")}:00`;
              timeMarker.appendChild(timeLabel);
            }

            timeScale.appendChild(timeMarker);
          }
        }

        columnElement.appendChild(timeScale);
      }

      // Функция для получения специалистов по массиву ID
      async function loadSpecialistsByIds(specialistIds) {
        try {
          const response = await fetch(`${API_BASE}/specialists/by-ids`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(specialistIds),
          });

          if (!response.ok) {
            throw new Error("Failed to load specialists: " + response.status);
          }

          return await response.json();
        } catch (error) {
          console.error("Error loading specialists by IDs:", error);
          throw error;
        }
      }

      // Функция для получения клиентов по specialistId
      async function getClientsBySpecialistId(specialistId) {
        try {
          const response = await fetch(
            `${API_BASE}/clients/by-specialist-id/${encodeURIComponent(
              specialistId
            )}`
          );

          if (!response.ok) {
            if (response.status === 404) {
              return [];
            }
            throw new Error("Failed to load CLIENTS: " + response.status);
          }

          return await response.json();
        } catch (error) {
          console.error("Error loading clients by specialistId:", error);
          throw error;
        }
      }

      // Частичное обновление клиента
      async function patchClient(clientId, updates) {
        try {
          const response = await fetch(`${API_BASE}/clients/${clientId}`, {
            method: "PATCH",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(updates),
          });

          if (!response.ok) {
            throw new Error("Failed to update client: " + response.status);
          }

          return await response.json();
        } catch (error) {
          console.error("Error patching client:", error);
          throw error;
        }
      }

      // Функция для расчета времени окончания приема
      function calculateEndTime() {
        const dateTimeInput = document.getElementById(
          "appointmentDateTime"
        ).value;
        const endTimeDisplay = document.getElementById("appointmentEndTime");

        if (dateTimeInput) {
          const startTime = new Date(dateTimeInput);
          // Добавляем 30 минут по умолчанию
          const endTime = new Date(startTime.getTime() + 30 * 60000);
          const formattedEndTime = endTime.toTimeString().slice(0, 5);
          endTimeDisplay.value = formattedEndTime;
        }
      }

      // Функция для поиска пользователя Telegram по ID
      async function searchTgUserById(tgUserId) {
        try {
          const responseSpecialist = await fetch(
            `${API_BASE}/specialists/${tgUserId}`
          );
          if (responseSpecialist.ok) {
            const tgSpecialist = await responseSpecialist.json();

            // TODO 1: Логика для специалиста
            currentSpecialist = tgSpecialist;
            document.getElementById("header").style.display = "none"; // Скрываем шапку для специалиста
            await loadAndDisplayClients(tgSpecialist);
          } else {
            const responseAdmin = await fetch(
              `${API_BASE}/administrators/${tgUserId}`
            );
            if (responseAdmin.ok) {
              const tgAdministrator = await responseAdmin.json();
              const specialistsIdList = tgAdministrator.specialistIdList
                .split("/")
                .filter((id) => id.length > 1)
                .map((id) => parseInt(id.trim()));

              try {
                const specialists = await loadSpecialistsByIds(
                  specialistsIdList
                );

                // TODO 3: Логика для администратора
                document.getElementById("header").style.display = "block"; // Показываем шапку для администратора
                createSpecialistButtons(specialists);
                if (specialists.length > 0) {
                  currentSpecialist = specialists[0];
                  await loadAndDisplayClients(specialists[0]);
                }
              } catch (error) {
                alert("Error loading SPECIALISTS: " + error.message);
              }
            } else {
              if (responseAdmin.status === 404) {
                // TODO 4: Логика для гостя
                document.getElementById("columnsContainer").innerHTML =
                  '<div class="guest-message">Здравствуйте, гость!</div>';
              } else {
                throw new Error(
                  "Failed to load tgUser: " + responseAdmin.status
                );
              }
            }
          }
        } catch (error) {
          console.error("Error loading user by ID:", error);
          alert("Error loading user: " + error.message);
        }
      }

      // Создание кнопок специалистов в шапке
      function createSpecialistButtons(specialists) {
        const keysContainer = document.getElementById("keysContainer");
        keysContainer.innerHTML = "";

        specialists.forEach((specialist) => {
          const keyButton = document.createElement("button");
          keyButton.className = "key-button";
          keyButton.textContent = `${specialist.surname} ${specialist.name} ${specialist.patronymic}`;
          keyButton.setAttribute("data-specialist-id", specialist.id);

          keyButton.addEventListener("click", async function () {
            currentSpecialist = specialist;
            await loadAndDisplayClients(specialist);
          });

          keysContainer.appendChild(keyButton);
        });
      }

      // Загрузка и отображение клиентов специалиста
      async function loadAndDisplayClients(specialist) {
        try {
          currentClients = await getClientsBySpecialistId(specialist.id);
          createColumnsWithAppointments(currentClients);
        } catch (error) {
          console.error("Error loading clients:", error);
          alert("Error loading clients: " + error.message);
        }
      }

      // Создание столбцов с записями
      function createColumnsWithAppointments(clients) {
        const container = document.getElementById("columnsContainer");
        container.innerHTML = "";

        // Собираем все даты приемов
        const allAppointments = [];
        clients.forEach((client) => {
          if (client.appointmentDateTime) {
            const appointments = client.appointmentDateTime
              .split("#")
              .filter((app) => app.trim());

            appointments.forEach((appointment, index) => {
              // Новый формат: "dd.MM.yyyy - HH:mm/HH:mm"
              const [dateTimePart, timeRange] = appointment.split(" - ");
              if (timeRange && timeRange.includes("/")) {
                const [startTimeStr, endTimeStr] = timeRange.split("/");

                const startTime = new Date(
                  `${dateTimePart
                    .split(".")
                    .reverse()
                    .join("-")}T${startTimeStr}`
                );
                const endTime = new Date(
                  `${dateTimePart.split(".").reverse().join("-")}T${endTimeStr}`
                );

                // Вычисляем продолжительность в минутах
                const duration = (endTime - startTime) / 60000;

                allAppointments.push({
                  client: client,
                  dateTime: startTime,
                  duration: duration,
                  appointmentIndex: index,
                  endTime: endTime,
                  appointmentString: appointment, // Сохраняем исходную строку
                });
              }
            });
          }
        });

        // Сортируем по дате
        allAppointments.sort((a, b) => a.dateTime - b.dateTime);

        // Группируем по датам
        const appointmentsByDate = {};
        allAppointments.forEach((appointment) => {
          const dateKey = appointment.dateTime.toLocaleDateString("ru-RU");
          if (!appointmentsByDate[dateKey]) {
            appointmentsByDate[dateKey] = [];
          }
          appointmentsByDate[dateKey].push(appointment);
        });

        // Создаем столбцы для каждой даты
        const dates = Object.keys(appointmentsByDate).sort(
          (a, b) =>
            new Date(a.split(".").reverse().join("-")) -
            new Date(b.split(".").reverse().join("-"))
        );

        dates.forEach((date) => {
          createColumn(date, appointmentsByDate[date]);
        });

        // Добавляем пустой столбец для новой записи
        createEmptyColumn();
      }

      // Создание столбца с записями
      function createColumn(date, appointments) {
        const container = document.getElementById("columnsContainer");

        const column = document.createElement("div");
        column.className = "column";
        column.innerHTML = `
            <div class="column-content">
                <h2>${date}</h2>
                <div class="cards-container" id="cards-${date}">
                </div>
            </div>
        `;

        createTimeScale(column);

        const cardsContainer = column.querySelector(".cards-container");

        // Сортируем записи по времени
        appointments.sort((a, b) => a.dateTime - b.dateTime);

        appointments.forEach((appointment) => {
          const card = createAppointmentCard(appointment);
          cardsContainer.appendChild(card);
        });

        column.addEventListener("click", function (e) {
          if (
            e.target === column ||
            e.target.classList.contains("empty-column") ||
            e.target.classList.contains("cards-container")
          ) {
            openAddModal();
          }
        });

        container.appendChild(column);
      }

      // Создание карточки записи
      function createAppointmentCard(appointment) {
        const card = document.createElement("div");
        card.className = "card";

        // Высота карточки зависит от продолжительности приема (1.05px за минуту)
        const height = appointment.duration * 1.05;
        card.style.height = `${height}px`;

        // Позиционирование карточки относительно времени приема
        const startTime = appointment.dateTime;
        const hours = startTime.getHours();
        const minutes = startTime.getMinutes();

        // Вычисление позиции карточки относительно верха столбца (0px = 08:00, 840px = 22:00)
        const totalMinutesFrom8 = (hours - 8) * 60 + minutes;
        const topPosition = (totalMinutesFrom8 / 840) * 900;

        card.style.top = `${topPosition}px`;

        const startTimeStr = startTime.toLocaleTimeString("ru-RU", {
          hour: "2-digit",
          minute: "2-digit",
        });

        const endTimeStr = appointment.endTime.toLocaleTimeString("ru-RU", {
          hour: "2-digit",
          minute: "2-digit",
        });

        // Форматируем ФИО в формат "Фамилия И.О."
        const formattedName = formatFullName(
          appointment.client.surname,
          appointment.client.name,
          appointment.client.patronymic
        );

        // Наполнение карточки контентом зависит от ее размера
        if (height > 50) {
          card.innerHTML = `
            <h3>${formattedName}</h3>
            <p>${appointment.client.phoneNumber}</p> 
            <p>${startTimeStr} - ${endTimeStr}</p>
        `;
        } else if (height > 30) {
          card.innerHTML = `
            <p>${formattedName}</p>
            <p>${startTimeStr} - ${endTimeStr}</p>
        `;
        } else {
          card.style.backgroundColor = "#ffc457";
          card.innerHTML = `
            <p>${startTimeStr} - ${endTimeStr}</p>
        `;
        }

        card.addEventListener("click", function (e) {
          e.stopPropagation();
          openViewModal(appointment.client, appointment.appointmentIndex);
        });

        return card;
      }

      // Создание пустого столбца
      function createEmptyColumn() {
        const container = document.getElementById("columnsContainer");

        const column = document.createElement("div");
        column.className = "column";
        column.innerHTML = `
            <div class="column-content">
                <h2>Новая запись</h2>
                <div class="cards-container">
                    <div class="empty-column">Кликните для записи</div>
                </div>
            </div>
        `;

        createTimeScale(column);

        column.addEventListener("click", function (e) {
          if (
            e.target === column ||
            e.target.classList.contains("empty-column") ||
            e.target.classList.contains("cards-container")
          ) {
            openAddModal();
          }
        });

        container.appendChild(column);
      }

      // Открытие модального окна добавления записи
      function openAddModal() {
        document.getElementById("addModal").style.display = "block";
        document.getElementById("searchClient").value = "";
        document.getElementById("searchResults").innerHTML = "";
        document.getElementById("appointmentDateTime").value = "";
        document.getElementById("appointmentEndTime").value = "";
        document.getElementById("appointmentNote").value = "";
        document.getElementById("searchClient").focus();
      }

      // Закрытие модального окна добавления записи
      function closeAddModal() {
        document.getElementById("addModal").style.display = "none";
        currentSelectedClient = null;
      }

      // Открытие модального окна просмотра записи
      function openViewModal(client, appointmentIndex) {
        currentSelectedClient = client;
        currentAppointmentIndex = appointmentIndex;

        const appointments = client.appointmentDateTime
          .split("#")
          .filter((app) => app.trim());
        const notes = client.appointmentNote
          ? client.appointmentNote.split("#").filter((note) => note.trim())
          : [];

        const appointment = appointments[appointmentIndex];
        const note = notes[appointmentIndex] || "";

        // Парсим новый формат: "dd.MM.yyyy - HH:mm/HH:mm"
        let displayText = appointment;
        if (appointment.includes(" - ") && appointment.includes("/")) {
          const [datePart, timePart] = appointment.split(" - ");
          const [startTime, endTime] = timePart.split("/");
          displayText = `${datePart} с ${startTime} до ${endTime}`;
        }

        document.getElementById("clientInfo").innerHTML = `
            <h4><strong>Клиент:</strong> ${client.surname} ${client.name} ${
          client.patronymic
        }</h4>
        <a href="tel:${client.phoneNumber}">${
          client.phoneNumber || "Телефонный номер не указан"
        }</a>
            <p><strong>Дата рождения:</strong> ${
              client.birthdate || "Не указана"
            }</p>
            <p><strong>Дата и время приема:</strong> ${displayText}</p>
            <p><strong>Комментарий:</strong> ${note}</p>
        `;

        document.getElementById("viewModal").style.display = "block";
      }

      // Закрытие модального окна просмотра
      function closeViewModal() {
        document.getElementById("viewModal").style.display = "none";
        currentSelectedClient = null;
        currentAppointmentIndex = null;
      }

      // Сохранение записи
      async function saveAppointment() {
        try {
          // Получаем данные из формы
          const dateTimeInput = document.getElementById(
            "appointmentDateTime"
          ).value;
          const endTimeInput =
            document.getElementById("appointmentEndTime").value;
          const noteInput = document.getElementById("appointmentNote").value;

          // Проверка обязательных полей
          if (!currentSelectedClient) {
            alert("Пожалуйста, выберите клиента");
            return;
          }

          if (!dateTimeInput) {
            alert("Пожалуйста, укажите дату и время начала приема");
            return;
          }

          if (!endTimeInput) {
            alert("Пожалуйста, укажите время окончания приема");
            return;
          }

          // Извлекаем время начала из datetime-local
          const startDateTime = new Date(dateTimeInput);
          const startTimeStr = startDateTime.toTimeString().slice(0, 5);

          // Проверяем что время окончания больше времени начала
          if (startTimeStr >= endTimeInput) {
            alert("Время окончания должно быть позже времени начала");
            return;
          }

          // Преобразование формата даты из "YYYY-MM-DD" в "dd.MM.yyyy"
          const formattedDate = `${startDateTime
            .getDate()
            .toString()
            .padStart(2, "0")}.${(startDateTime.getMonth() + 1)
            .toString()
            .padStart(2, "0")}.${startDateTime.getFullYear()}`;

          // Формируем запись в новом формате: "dd.MM.yyyy - HH:mm/HH:mm"
          const newAppointment = `${formattedDate} - ${startTimeStr}/${endTimeInput}`;

          // Проверка времени (не ранее 08:00 и не позже 22:00)
          const startHours = parseInt(startTimeStr.split(":")[0]);
          const startMinutes = parseInt(startTimeStr.split(":")[1]);
          const endHours = parseInt(endTimeInput.split(":")[0]);
          const endMinutes = parseInt(endTimeInput.split(":")[1]);

          if (
            startHours < 8 ||
            (startHours === 22 && startMinutes > 0) ||
            startHours > 22
          ) {
            alert("Время начала приема должно быть с 08:00 до 22:00");
            return;
          }

          if (endHours > 22 || (endHours === 22 && endMinutes > 0)) {
            alert("Время окончания приема не может быть позже 22:00");
            return;
          }

          // Проверка что дата не ранее текущей
          const now = new Date();
          if (startDateTime < now) {
            alert("Нельзя записать на прошедшую дату");
            return;
          }

          // Проверка наложения на существующие записи
          const hasOverlap = await checkAppointmentOverlap(newAppointment);
          if (hasOverlap) {
            alert(
              "Выбранное время накладывается на существующую запись. Пожалуйста, выберите другое время."
            );
            return;
          }

          // Подготовка данных для обновления
          const updates = {};

          // Обновление appointmentDateTime в новом формате
          const currentAppointments = currentSelectedClient.appointmentDateTime
            ? currentSelectedClient.appointmentDateTime
                .split("#")
                .filter((app) => app.trim())
            : [];
          currentAppointments.push(newAppointment);
          updates.appointmentDateTime = currentAppointments.join("#") + "#";

          // Обновление appointmentNote (если есть комментарий)
          if (noteInput.trim()) {
            const currentNotes = currentSelectedClient.appointmentNote
              ? currentSelectedClient.appointmentNote
                  .split("#")
                  .filter((note) => note.trim())
              : [];
            currentNotes.push(noteInput.trim());
            updates.appointmentNote = currentNotes.join("#") + "#";
          }

          // Отправка PATCH запроса
          const response = await fetch(
            `${API_BASE}/clients/${currentSelectedClient.id}`,
            {
              method: "PATCH",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify(updates),
            }
          );

          if (!response.ok) {
            throw new Error("Ошибка при сохранении записи: " + response.status);
          }

          // Обновление интерфейса
          closeAddModal();

          // Перезагрузка данных
          await loadAndDisplayClients(currentSpecialist);
        } catch (error) {
          console.error("Error saving appointment:", error);
          alert("Ошибка при сохранении записи: " + error.message);
        }
      }

      // Отмена записи
      async function cancelAppointment() {
        if (currentSelectedClient && currentAppointmentIndex !== null) {
          try {
            // Подтверждение отмены
            const isConfirmed = confirm("Подтвердите отмену записи");
            if (!isConfirmed) {
              closeViewModal();
              return;
            }

            // Получение текущих данных
            const currentAppointments =
              currentSelectedClient.appointmentDateTime
                ? currentSelectedClient.appointmentDateTime
                    .split("#")
                    .filter((app) => app.trim())
                : [];

            const currentNotes = currentSelectedClient.appointmentNote
              ? currentSelectedClient.appointmentNote
                  .split("#")
                  .filter((note) => note.trim())
              : [];

            // Удаление записи по индексу
            if (currentAppointmentIndex < currentAppointments.length) {
              currentAppointments.splice(currentAppointmentIndex, 1);
              if (currentNotes.length > currentAppointmentIndex) {
                currentNotes.splice(currentAppointmentIndex, 1);
              }
            }

            // Подготовка данных для обновления
            const updates = {
              appointmentDateTime:
                currentAppointments.join("#") +
                (currentAppointments.length > 0 ? "#" : ""),
            };

            // Сохранение заметок только если они есть
            if (currentNotes.length > 0) {
              updates.appointmentNote = currentNotes.join("#") + "#";
            } else {
              updates.appointmentNote = "";
            }

            // Отправка PATCH запроса
            const response = await fetch(
              `${API_BASE}/clients/${currentSelectedClient.id}`,
              {
                method: "PATCH",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify(updates),
              }
            );

            if (!response.ok) {
              throw new Error("Ошибка при отмене записи: " + response.status);
            }

            // Обновление интерфейса
            closeViewModal();

            // Перезагрузка данных
            await loadAndDisplayClients(currentSpecialist);
          } catch (error) {
            console.error("Error canceling appointment:", error);
            alert("Ошибка при отмене записи: " + error.message);
          }
        }
      }

      // Вспомогательная функция для проверки наложения записей
      async function checkAppointmentOverlap(newAppointment) {
        try {
          // Получаем всех клиентов текущего специалиста
          const clients = await getClientsBySpecialistId(currentSpecialist.id);

          // Парсим новую запись в новом формате: "dd.MM.yyyy - HH:mm/HH:mm"
          const [newDatePart, newTimePart] = newAppointment.split(" - ");
          const [newStartTimeStr, newEndTimeStr] = newTimePart.split("/");
          const [day, month, year] = newDatePart.split(".");

          const newStart = new Date(
            `${year}-${month}-${day}T${newStartTimeStr}`
          );
          const newEnd = new Date(`${year}-${month}-${day}T${newEndTimeStr}`);

          // Проверяем все существующие записи
          for (const client of clients) {
            if (client.appointmentDateTime) {
              const appointments = client.appointmentDateTime
                .split("#")
                .filter((app) => app.trim());

              for (let i = 0; i < appointments.length; i++) {
                const appointment = appointments[i];

                // Парсим существующую запись в новом формате
                if (appointment.includes(" - ") && appointment.includes("/")) {
                  const [datePart, timePart] = appointment.split(" - ");
                  const [startTimeStr, endTimeStr] = timePart.split("/");
                  const [day, month, year] = datePart.split(".");

                  const existingStart = new Date(
                    `${year}-${month}-${day}T${startTimeStr}`
                  );
                  const existingEnd = new Date(
                    `${year}-${month}-${day}T${endTimeStr}`
                  );

                  // Проверка пересечения временных интервалов
                  if (
                    (newStart >= existingStart && newStart < existingEnd) ||
                    (newEnd > existingStart && newEnd <= existingEnd) ||
                    (newStart <= existingStart && newEnd >= existingEnd)
                  ) {
                    return true; // Найдено пересечение
                  }
                }
              }
            }
          }

          return false; // Пересечений нет
        } catch (error) {
          console.error("Error checking appointment overlap:", error);
          return true; // В случае ошибки считаем что есть пересечение (для безопасности)
        }
      }

      // Поиск клиента
      document
        .getElementById("searchClient")
        .addEventListener("input", function (e) {
          const searchTerm = e.target.value.toLowerCase();
          const resultsContainer = document.getElementById("searchResults");
          resultsContainer.innerHTML = "";

          if (searchTerm.length > 2) {
            const filteredClients = currentClients.filter((client) =>
              `${client.surname} ${client.name} ${client.patronymic}`
                .toLowerCase()
                .includes(searchTerm)
            );

            filteredClients.forEach((client) => {
              const resultItem = document.createElement("div");
              resultItem.style.padding = "8px";
              resultItem.style.borderBottom = "1px solid #eee";
              resultItem.style.cursor = "pointer";
              resultItem.textContent = `${client.surname} ${client.name} ${client.patronymic}`;

              resultItem.addEventListener("click", function () {
                currentSelectedClient = client;
                document.getElementById(
                  "searchClient"
                ).value = `${client.surname} ${client.name} ${client.patronymic}`;
                resultsContainer.innerHTML = "";
              });

              resultsContainer.appendChild(resultItem);
            });
          }
        });

      // Обработка нажатия Enter в поле поиска
      document
        .getElementById("searchClient")
        .addEventListener("keypress", function (e) {
          if (e.key === "Enter") {
            e.preventDefault();
          }
        });

      // Обработчики для автоматического заполнения времени окончания
      document
        .getElementById("appointmentDateTime")
        .addEventListener("change", calculateEndTime);

      // Закрытие модальных окон при клике вне их
      window.addEventListener("click", function (e) {
        const addModal = document.getElementById("addModal");
        const viewModal = document.getElementById("viewModal");

        if (e.target === addModal) {
          closeAddModal();
        }
        if (e.target === viewModal) {
          closeViewModal();
        }
      });

      // Инициализация при загрузке страницы
      document.addEventListener("DOMContentLoaded", function () {
        searchTgUserById(tgUserId);
      });
    </script>
  </body>
</html>
